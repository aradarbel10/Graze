use std::str::FromStr;
use crate::raw::*;

grammar;

Comma<T> : Vec<T> = {
  <mut v : (<T> ",")*> <e:T?> => match e {
    None => v,
    Some(e) => {
      v.push(e);
      v
    }
  }
};

CommaTwo<T> : Vec<T> = {
  <v : T> "," <mut vs : Comma<T>> => {
    vs.insert(0, v);
    vs
  }
};


Num : i32 = <s : r"[0-9]+"> => i32::from_str(s).unwrap();
Char : char = <c : r"'.'"> => char::from_str(c).unwrap();
Ident : String = <id : r"[a-zA-Z][a-zA-Z0-9]*"> => id.to_string();

// multiple [P]recedence levels
OpP1 : BinOp = {
  ">"  => BinOp::GT,
  ">=" => BinOp::GTE,
  "<"  => BinOp::LT,
  "<=" => BinOp::LTE,
  "==" => BinOp::Eq,
};
ExprP1 : Box<Expr> = {
  <l : ExprP2> <op : OpP1> <r : ExprP2> => Box::new(Expr::BinOp(op, l, r)),
  <l : ExprP1> "@" <r : ExprP2> => Box::new(Expr::BinOp(BinOp::Index, l, r)),
  ExprP2
};

OpP2 : BinOp = {
  "+"  => BinOp::Add,
  "-"  => BinOp::Sub,
  "||" => BinOp::Or,
  "<<" => BinOp::Shl,
  ">>" => BinOp::Shr,
};
ExprP2 : Box<Expr> = {
  <l : ExprP2> <op : OpP2> <r : ExprP3> => Box::new(Expr::BinOp(op, l, r)),
  ExprP3,
};

OpP3 : BinOp = {
  "*"  => BinOp::Mul,
  "/"  => BinOp::Div,
  "%"  => BinOp::Mod,
  "&&" => BinOp::And,
  "^^" => BinOp::Xor,
};
ExprP3 : Box<Expr> = {
  <l : ExprP3> <op : OpP3> <r : ExprPrefix> => Box::new(Expr::BinOp(op, l, r)),
  <e : ExprPrefix> => e,
};

ExprPrefixUnboxed : Expr = {
  "!" <e : ExprPrefix> => Expr::Deref(e),
  "~" <e : ExprPrefix> => Expr::Not(e),
  "new" <e : ExprPrefix> => Expr::New(e),
  "free" <e : ExprPrefix> => Expr::Free(e),
  "allocate" <e : Atom> "in" <r : ExprPrefix> => Expr::Allocate(e, r),
  <e : Atom> => *e,
};
ExprPrefix : Box<Expr> = ExprPrefixUnboxed => Box::new(<>);

Atom : Box<Expr> = {
  <id : Ident> => Box::new(Expr::Var(id)),
  // literals
  <n : Num> => Box::new(Expr::IntLit(n)),
  "true" => Box::new(Expr::BoolLit(true)),
  "false" => Box::new(Expr::BoolLit(false)),
  <c : Char> => Box::new(Expr::CharLit(c)),
  "()" => Box::new(Expr::Unit),
  // operators
  "(" <e : ExprP1> ")" => e,
  // function calls
  <f : Ident> "(" <args : Comma<Expr>> ")" =>
    Box::new(
      Expr::FunCall(f, None, args.into_iter().map(|boxed| *boxed).collect())
    ),
  <f : Ident> "[" <targs : Comma<Type>> "]" "(" <args : Comma<Expr>> ")" =>
    Box::new(  
      Expr::FunCall(f,
        Some(targs),
        args.into_iter().map(|boxed| *boxed).collect())
    ),
  // products
  <r : Ident> "{" <fs : Comma<FieldVal>> "}" => Box::new(Expr::Record(r, fs)),
  <e : Atom> "." <l : Ident> => Box::new(Expr::Proj(e, l)),
  "(" <es : CommaTwo<Expr>> ")" =>
    Box::new(Expr::Tuple(
      es.into_iter().map(|boxed| *boxed).collect()
    )),
  "[" <es : Comma<Expr>> "]" =>
    Box::new(Expr::ListLit(
      es.into_iter().map(|boxed| *boxed).collect()
    )),
  // memory
  "new" "region" => Box::new(Expr::NewRegion),
};

FieldVal : FieldVal = {
  <n : Ident> "=" <v : Expr> => FieldVal {
    nam: n,
    val: v,
  }
};

pub Expr = { ExprP1 };



// Type grammar
pub Type : Type = {
  <t : Type> "#" <n : Num> => Type::List(Box::new(t), n),
  TypeAtom
};
TypeAtom : Type = {
  "i32" => Type::Int32,
  "bool" => Type::Boolean,
  "char" => Type::Char,
  "()" => Type::Unit,
  "(" <ts : CommaTwo<Type>> ")" => Type::Prod(ts),
  <x : Ident> => Type::TypVar(x),
  <x : Ident> "[" <ts : Comma<Type>> "]" => Type::TypApp(x, ts),
  "&" <t : TypeAtom> => Type::Ptr(Box::new(t)),
  "mut" <t : TypeAtom> => Type::Mut(Box::new(t)),
  "region" => Type::Region,
  "(" <t : Type> ")" => t,
};


// Pattern language
PipeTwo<T> : Vec<T> = {
  <t : T> <mut ts : ("|" <T>)+> => {
    ts.insert(0, t); ts
  }
};

pub Pattern : Pattern = {
  <ps : PipeTwo<PatternAtom>> => Pattern::Or(ps),
  PatternAtom,
};

PatternAtom : Pattern = {
  "_" => Pattern::Wildcard,
  Ident => Pattern::Var(<>),
  "(" <ps : CommaTwo<Pattern>> ")" => Pattern::Tuple(ps),
  "[" <ps : CommaTwo<Pattern>> "]" => Pattern::List(ps),
  <x : Ident> "(" <ps : Comma<Pattern>> ")" => Pattern::Ctor(x, ps),
  "(" <p : Pattern> ")" => p,
};


// Statements
pub Block : Vec<Stmt> = <ss : Stmt+> => ss;

Branch : Branch = {
  "|" <p : Pattern> "=>" <b : Block> => Branch {pat: p, bod: b},
};

pub Stmt : Stmt = {
  "if" <e : Expr> "then" <b : Block> "end" => Stmt::IfThen(*e, b),
  "if" <e : Expr> "then" <b1 : Block> "else" <b2 : Block> "end" =>
    Stmt::IfThenElse(*e, b1, b2),
  "match" <e : Expr> "with" <bs : Branch+> "end" => Stmt::Match(*e, bs),
  "begin" <b : Block> "end" => Stmt::Block(b),
  "foreach" <x : Ident> "in" <e : Expr> "do" <b : Block> "end" =>
    Stmt::ForEach(x, *e, b),
  "while" <e : Expr> "do" <b : Block> "end" => Stmt::WhileLoop(*e, b),
  "let" <p : Pattern> <t : (":" <Type>)?> "=" <e : Expr> ";" =>
    Stmt::VarDecl(p, t, *e),
  "set" <l : Expr> "=" <r : Expr> ";" =>
    Stmt::VarAssgn(*l, *r),
  "ret" <e : Expr> ";" => Stmt::Return(*e),
  <e : Expr> ";" => Stmt::ExprStmt(*e),
};